---
title: "Subjective povery lines:"
subtitle: "Estimates from reported minimum income"
author: 
  - "Steven F. Koch^[Corresponding author: Department of Economics, University of Pretoria, Private Bag X20, Hatfield, South Africa; +27-12-420-5285; steve.koch@up.ac.za]"
thanks: The author would like to thank someone for their comments and suggestions. Any remaining issues rest with the author.
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  bookdown::pdf_document2: 
    latex_engine: xelatex
    dev: tikz
    keep_tex: true
    number_sections: true
    toc: false
  bookdown::gitbook: null
booktabs: yes
header-includes:
    - \usepackage{setspace}\doublespacing
    - \usepackage{dcolumn}
    - \pagenumbering{gobble}
abstract: \singlespacing We consider minimum income questions to examine eq scales.
---
<!-- bibliography: refs.bib 
     there seems to be a problem with the bib file, 
     but I do not understand why it arises...
     
     Error reading bibliography file refs.bib:
    (line 288, column 1):
     unexpected '@'
    
-->

<!--
    - \usepackage{draftwatermark}
\SetWatermarkText{Draft}
\AddToShipoutPictureFG{
  \AtPageCenter{% or \AtTextCenter
    \makebox[0pt]{\rotatebox[origin=c]{45}{%
      \scalebox{5}{\texttransparent{0.3}{Draft}}%
    }}
  }
}
-->

<!-- subject: JEL Classifications I15, J21
thanks: The authors would like to thank someone. 
csl: empirical-economics.csl 
-->

```{r global_options, include=FALSE, cache=FALSE}
knitr::opts_chunk$set(cache=TRUE,
                      echo=FALSE,
                      autodep=TRUE,
                      message=FALSE,
                      warning=FALSE,
                      #dev='tikz',
                      dev='pdf',
                      out.width='60%',
                      out.height='60%',
                      fig.align='center')

def.chunk.hook  <- knitr::knit_hooks$get("chunk")
knitr::knit_hooks$set(chunk = function(x, options) {
  x <- def.chunk.hook(x, options)
  ifelse(options$size != "normalsize", paste0("\\", options$size,"\n\n", x, "\n\n \\normalsize"), x)
})

knitr::opts_knit$set(kable.force.latex = TRUE)

library(tidyverse)
library(haven)
library(lubridate)
library(kableExtra)
library(np)    
library(nnet)
library(AER)
library(ivreg)
library(sandwich)
library(REndo)
library(qwraps2)
  options(qwraps2_markup = "latex")
library(stargazer)
library(MASS)


options(scipen = 99,
        np.messages=FALSE)

set.seed(42)
num.boot <- 1499 
num.splits <- 5000
q1 <- 0.025
q2 <- 0.975
nmulti <- 20

### Working Directory
#setwd('/Volumes/GoogleDrive/My Drive/Inequality/EqScalesFood')
```

```{r some-functions}
### Some useful functions ###

CM <- function(cm) {
  factor.values.eval <- colnames(cm)
  CM <- matrix(0,nrow(cm),nrow(cm))
  rownames(CM) <- rownames(cm)
  colnames(CM) <- rownames(cm)
  for(i in 1:ncol(cm)) CM[,(1:nrow(cm))[rownames(cm)==factor.values.eval[i]]] <- cm[,i]
  return(list(CM=CM,CCR=sum(diag(CM))/sum(CM)))
}

## this is a bit silly, but is driven by the difference in names between 
## prediction and model... Could also change the model data naming...
CM.logit <- function(cm) {
  factor.values.eval <- rownames(cm)
  CM <- matrix(0,nrow(cm),nrow(cm))
  rownames(CM) <- rownames(cm)
  colnames(CM) <- rownames(cm)
  for(i in 1:ncol(cm)) CM[,(1:nrow(cm))[rownames(cm)==factor.values.eval[i]]] <- cm[,i]
  return(list(CM=CM,CCR=sum(diag(CM))/sum(CM)))
}

stars <- function(x){
  case_when(x >=0 & x <= 0.005 ~ "$^a$", 
            x >=0 & x <= 0.01 ~ "$^b$",
            x >=0 & x <= 0.05 ~ "$^c$",
            x >=0 & x <= 0.1 ~ "$^d$",
            x>0.1 ~ "")
}

ctab <- function(sm){
  mm <- summary(sm,vcov=vcovHC(sm))
  modsum <- mm$coefficients
  n <- rownames(modsum)
  ses <- paste0("(",formatC(modsum[,2],format="f",digits=3, drop0trailing = F),")")
  z <- stars(modsum[,4])
  betas <- paste0(formatC(modsum[,1],format="f",digits=4, drop0trailing = F),z)
  t1 <- tibble(n=n,b=betas,s=ses) %>%
    pivot_longer(!n,names_to="params",values_to = "results")
}

nlstab <- function(sm){
  modsum <- sm$parameters
  n <- rownames(modsum)
  CIs <- paste0("(",format(modsum[,1]-1.96*modsum[,2],digits=1,nsmall=2)," -- ",
                format(modsum[,1]+1.96*modsum[,2],digits=1,nsmall=2), ")")
  betas <- format(modsum[,1],digits=1,nsmall=4)
  t1 <- tibble(n=n,b=betas,s=CIs) %>%
    pivot_longer(!n,names_to="params",values_to = "results")
}

ivctab <- function(sm){
  mm <- summary(sm)
  modsum <- mm$coefficients
  n <- rownames(modsum)
  ses <- paste0("(",formatC(modsum[,2],format="f",digits=3, drop0trailing = F),")")
  z <- stars(modsum[,4])
  betas <- paste0(formatC(modsum[,1],format="f",digits=4, drop0trailing = F),z)
  t1 <- tibble(n=n,b=betas,s=ses) %>%
    pivot_longer(!n,names_to="params",values_to = "results")
  modnost <- sm$diagnostics
  nn <- rownames(modnost)
  degfree1 <- as.character(modnost[,1])
  z1 <- stars(modnost[,4])
  ivstat <- paste0(formatC(modnost[,3],format="f",digits=3, drop0trailing = F),z1)
  t2 <- tibble(n=nn,params=degfree1,results=ivstat)
  t <- rbind(t1,t2)
}

sptab <- function(sm){
  modsum <- sm
  n <- rownames(modsum)
  colnames(sm) <- c("betas","ses")
  tt <- sm[,1]/sm[,2]
  pp <- 2*pnorm(-abs(tt))
  n <- rownames(modsum)
  ses <- paste0("(",format(modsum[,2],digits=1,nsmall=3),")")
  z <- stars(pp)
  betas <- paste0(format(modsum[,1],digits=1,nsmall=4),z)
  t1 <- tibble(n=n,b=betas,s=ses) %>%
    pivot_longer(!n,names_to="params",values_to = "results")
}

estab <- function(sm){
  sm.all <- sm
  sm <- as.matrix(sm)
  n <- paste0(sm[,1]," ",sm[,2])
  ses <- paste0("(",formatC(as.numeric(sm[,4]),format="f",digits=0, drop0trailing = F),")")
  #z <- stars(sm[,4]) - not the right function, and not going to include.
  sm3.form <- formatC(as.numeric(sm[,3]),format="f",digits=0)
  #betas <- paste0(sm3.form,z)
  t1 <- tibble(n=n, b=sm3.form,s=ses) %>%
    pivot_longer(!n,names_to="result-type",values_to = "results") %>%
    separate(n, into =c("adults","kids"))
  estab.out <- t1[,c(1,2,4)]
}

only_perc <- function(x,
                   digits = getOption("qwraps2_frmt_digits", 2),
                   na_rm = FALSE,
                   show_denom = "ifNA",
                   show_symbol = TRUE,
                   markup = "latex") #getOption("qwraps2_markup", "latex")) 
                   {
  d <- sum(!is.na(x))
  n <- sum(x, na.rm = na_rm)
  p <- frmt(100*n/d, digits)

  if (show_denom == "never") {
    rtn <- paste0(p,"%")
  } else {
    if (show_denom =="always" | any(is.na(x))) {
      rtn <- paste0(frmt(as.integer(n)), "/", frmt(as.integer(d)), " (", p, "%)")
    } else {
      rtn <- paste0(p,"%")
    }
  }

  if (!show_symbol) {
    rtn <- gsub("%", "", rtn)
  }


  if (markup == "latex") {
    rtn <- gsub("%", "\\\\%", rtn)
  }

  return(rtn)
}

quadRoots <- function(a, b, c) {

print(paste0("You have chosen the quadratic equation ", a, "x^2 + ", b, "x + ", c, "."))

discriminant <- (b^2) - (4*a*c)

  if(discriminant < 0) {  # if discriminant is less than zero i.e no real roots
    return(paste0("This quadratic equation has no real numbered roots."))
  }
  else if(discriminant > 0) { # If discriminant is greater than 0 ie real roots
    x_int_plus <- (-b + sqrt(discriminant)) / (2*a)
    x_int_neg <- (-b - sqrt(discriminant)) / (2*a)

    return(paste0("The two x-intercepts for the quadratic equation are ",
                  format(round(x_int_plus, 5), nsmall = 5), " and ",
                  format(round(x_int_neg, 5), nsmall = 5), "."))
  }
  else #discriminant = 0  i.e only one root 
    x_int <- (-b) / (2*a)
    return(paste0("The quadratic equation has only one root. This root is ",
                  x_int))
}
```


```{r lcs}

# LCS data
person <- read_dta(file = "../LCSdata/lcs-2014-2015-persons-final-v1.dta")
total <- read_dta(file = "../LCSdata/lcs-2014-2015-total-v1.dta")
household <- read_dta(file = "../LCSdata/lcs-2014-2015-households-v1.dta")
#household.assets <- read_dta(file = "data/lcs-2014-2015-household-assets-v1.dta")

# hhsize, number of kids (age < 15) in each household
person1 <- person %>%
  group_by(UQNO) %>%
  summarise(hhsize = n(), # household size by appearance times of each ID
            kids = sum(Q14AGE < 15), # number of child (age<15)
            adults = hhsize - kids
            ) %>%
  mutate(UQNO = as.character(UQNO))

person2 <- person %>%
  dplyr::select(UQNO, PERSONNO, Q12SEX, Q13POPGROUP, Q14AGE, Q17MARITAL, Q21HIGHLEVEL, 
         province_code, SETTLEMENT_TYPE) %>%
  filter(PERSONNO==1, 
         Q17MARITAL != 9,
         Q21HIGHLEVEL != 31,
         Q21HIGHLEVEL != 32,
         Q21HIGHLEVEL != 99) %>%  
  transmute(UQNO = as.character(UQNO),
            age = Q14AGE,
            hhh.dummy = ifelse(Q12SEX==1,1,0),
            hhh.male = as_factor(Q12SEX),
            ethnic = as_factor(Q13POPGROUP),
            ba = ifelse(Q13POPGROUP==1,1,0),
            cl = ifelse(Q13POPGROUP==2,1,0),
            as = ifelse(Q13POPGROUP==3,1,0),
            wh = ifelse(Q13POPGROUP==4,1,0),
            wc = ifelse(province_code==1,1,0),
            ec = ifelse(province_code==2,1,0),
            nc = ifelse(province_code==3,1,0),
            fs = ifelse(province_code==4,1,0),
            kz = ifelse(province_code==5,1,0),
            nw = ifelse(province_code==6,1,0),
            gp = ifelse(province_code==7,1,0),
            mp = ifelse(province_code==8,1,0),
            lp = ifelse(province_code==9,1,0),
            province = as_factor(province_code),
            urbfor = ifelse(SETTLEMENT_TYPE==1,1,0),
            urbinf = ifelse(SETTLEMENT_TYPE==2,1,0),
            tradit = ifelse(SETTLEMENT_TYPE==4,1,0),
            rurfor = ifelse(SETTLEMENT_TYPE==5,1,0),
            settle = factor(SETTLEMENT_TYPE, levels = c(1,2,4,5),
                            labels=c("Urban Formal","Urban Informal",
                                     "Traditional Area","Rural Formal")),
            marital = as_factor(Q17MARITAL),
            education = factor(Q21HIGHLEVEL, levels = c(98,1:25,27,28:29,26,30),
                              labels=c("none",rep("nqf0",9),"nqf1","nqf2","nqf3",rep("nqf4",2),
                                       "nqf1","nqf2","nqf3",rep("nqf5",3), rep("nqf4",2),"nqf5",
                                       "nqf6",rep("nqf7",2),rep("nqf8",2),rep("nqf9-10",2))),
            Q21HIGHLEVEL) %>%
  droplevels() 

# household level variables
house.df <- household %>%
  dplyr::select(
    UQNO, income_inkind, expenditure_inkind, SURVEYDATE, Q229NETINCOME, 
    Q6105IMAGINE, Q116PRESENT, hholds_wgt) %>%
  filter(Q6105IMAGINE != 9, Q116PRESENT != 9) %>% ## loses 493 obs..
  transmute(
    UQNO = as.character(UQNO),
    wt = hholds_wgt,
    surveydate = dmy(SURVEYDATE),
    surveymonth = month(surveydate),
    surveyyear = year(surveydate),
    x = as.numeric(expenditure_inkind), 
    # the value of expenditures including in kind expenditure incurred by 
    # households for 12 months inflated/deflated to April 2015 using CPI
    x.month = x/12, #Monthly total expenditure
    y = as.numeric(income_inkind),  
    # 63 observations have 0 values... length(which(house.df$y==0))
    # also deflated/inflated to April 2015
    y.month = y/12,
    lnx = log(x.month),
    lny = log(y.month),
    minq = Q229NETINCOME, 
    # 466 zero values (after dropping the 493 above) ... length(which(house.df$minq == 0))
    lnminq = log(minq),
    ladder = Q6105IMAGINE,
    wealth = as_factor(Q116PRESENT)
  ) %>%
  filter(is.finite(lny),
         is.finite(lnx),
         is.finite(lnminq)) %>%  # Not sure this affects the final lcs data, though
  droplevels()
  


#merge above dataframes to get a dataframe LCS2014
LCS2014 <- person1 %>%
  full_join(person2, by="UQNO") %>%
  full_join(house.df, by="UQNO") %>%
  drop_na() %>%
  filter(adults > 0,
         adults <= 6,
         kids <= 4)
## It appears that we lose 312 observations for missing values, 
## we lose 556 in total; the extra coming from limiting adults and kids in hh
  
# save image
#save.image("data/LCS2014.Rdata")

# save a single data frame: LCS2014
#save(LCS2014, file="data/LCS2014df.Rdata")

rm(person,household,total)

data.full <- LCS2014 %>%
  mutate(ao = ordered(adults),
         ko = ordered(kids),
         k0 = 1*(kids==0),
         k1 = 1*(kids==1),
         k2 = 1*(kids==2),
         k3 = 1*(kids==3),
         k4 = 1*(kids==4),
       #  k5 = 1*(kids==5),
      #   k6 = 1*(kids==6),
         a1 = 1*(adults==1),
         a2 = 1*(adults==2),
         a3 = 1*(adults==3),
         a4 = 1*(adults==4),
         a5 = 1*(adults==5),
         a6 = 1*(adults==6),
       #  a7 = 1*(adults==7),
      #   a8 = 1*(adults==8),
         lnx.sq = lnx^2,
         lny.sq = lny^2,
         age.sq = age^2)


base.data <- data.full %>%
  dplyr::select(UQNO,ko, ao, age, age.sq, hhh.male, 
                k0,k1,k2,k3,k4,a1,a2,a3,a4,a5,a6,
                ethnic, province, settle, marital, education, 
                lnx, lnx.sq, lny, lny.sq, minq, lnminq) %>%
  transmute(lnx, lnx.sq, lny, lny.sq, ko, ao,
            k0,k1,k2,k3,k4,a1,a2,a3,a4,a5,a6, minq, lnminq,
            age = as.integer(age),
            age.sq = as.integer(age.sq),
            hhh.male = as.factor(hhh.male),
            ethnic = as.factor(ethnic),
            province = as.factor(province),
            settle = as.factor(settle),
            marital = as.factor(marital),
            education = as.factor(education)) 

main.df <- base.data
## Some parameters
n <- nrow(main.df)
n2 <- 24
n1 <- n-n2

#save(main.df, file="data/main.Rdata")
```


\newpage
\pagenumbering{arabic}

# Introduction??

@grodnersalas2017 - there is an update of that -  describe the information content of equivalence scales that can be captured from minimum needs income...  @blundelllewbel1991 and  describe the information content in equivalence scales. In order to make comparisons across households, @lewbel1989 describes ordinal level comparability, while @blackorbydonaldson1993 describe ordinal full comparability plus. These ideas relate to the ability to compare utility across households; the underlying information basis depends on the ability to calculate equivalence scales, and is only relevant for monotone transformations of utility that keep the scale constant. Most commonly, this is done through an Independence of Base assumption [@lewbel1989] or an Equivalence-Scale Exactness [@blackorbydonaldson1993] assumption, which are the same. Such restrictions are often rejected [@pendakur1999]^[I really need to do some checking on this with the SA data... I have started to do some of this analysis, but plausibly need to do more...]; A slightly weaker assumption can lead to general equivalence scales, which are not uniform across the entire population. One such weakening is to allow for monotone transformations, but only at a specific level of utility. In essence, making such a comparison relies on ordinal local comparability [@grodnersalas2017], and leads to local equivalence scales. 

One might wonder whether such scales are even useful. However, @blundelllewbel1991 suggested one solution that would help in the identification of demand systems, which @blackorbydonaldson1993 also suggested, arguing it was very relevant for policy. The suggestion was we should focus attention on utility levels that allow individuals to make ends meet, referring to this as the minimum level of utility. Furthermore, the poverty line is the level of income assumed/required for a household to reach that minimum level of utility.  

# Methods

## Subjective poverty lines and marginal costs

We apply fairly standard methods, assuming both a parametric and nonparametric relationship \eqref{eq:nprelation} between minimum income $(\underline{Y})$, actual income $(Y)$, household demographic characteristics $(D)$ and other characteristics related to household decisions, such as location and marital status, $(Z)$. Equation \eqref{eq:nprelation} represents the general structure, which assumes no functional form. 
\begin{equation}
\label{eq:nprelation}
\ln \underline{Y} = f(Y,D,Z)
\end{equation}
We tighten the functional form assumption, first, assuming simple linearity, as in \eqref{eq:linindex}.
\begin{equation}
\label{eq:linindex}
\ln \underline{Y} = \alpha + \beta \ln Y + \sum_j \delta_j D_j + \sum_j \zeta_j Z_j 
\end{equation}
Finally, we extend that to allow for a potential quadratic relationship, as in \eqref{eq:quad}. 
\begin{equation}
\label{eq:linindex}
\ln \underline{Y} = \alpha + \beta \ln Y + \gamma \left( \ln Y \right) + \sum_j \delta_j D_j + \sum_j \zeta_j Z_j 
\end{equation}

Subjective poverty lines are described as fixed points [@Goedhartetal1977], where $\ln \underline{Y} = f(\ln Y, D, Z)$. Under linearity, that fixed point occurs at the intercept, adjusted for the regression slope.
\begin{equation}
\label{eq:linear-spl}
\underline{Y} =   \frac{\alpha + \sum_j \delta_j D_j + \sum_j \zeta_j Z_j }{1-\beta} 
\end{equation}
With a quadratic term in the regression, the fixed point is determined by the solution to the quadratic formula, where we will limit our attention to real roots.^[At this point, I am not sure if we will have complex root "problems". If we do not, we just need to mention that. If we do, we will have to comment about how common the violation is, and what we had to do to eliminate it.] For the general equation, we will apply simulation methods, searching for the value of $\ln \underline{Y} = f(\ln \underline Y, D, Z)$, conditional on $D$ and $Z$. 

Technically, we net out all of the $Z$ factors; they are included in the regression, but are not allowed to vary for the calculation of subjective poverty. However, it is possible to calculate different subjective poverty lines for different regions of the country, or other subgroups by altering the calculation structure.

<!--
Rearranging to find the intersection - goedhart - yields the subjective poverty line, as a function of the demographic and other characteristics \eqref{eq:spl}.

\begin{equation}
\label{eq:spl}
\underline{Y} =  \exp \left( \frac{\alpha + \sum_j \delta_j D_j + \sum_j \zeta_j Z_j }{1-\beta} \right)
\end{equation}

From these subjective poverty lines, marginal child and adult costs can be derived for each additional household member $(h \in \{a,k\})$, where $a$ and $k$ refer to adult and child, respectively, while $\underline{Y}^*$ is the reference household, which we will define as having one adult and zero children. **Is this independent of the number of adults and children already in the house? As before, we can turn off the "other" variables?** 

\begin{equation}
\label{eq:margcost}
M(h) = \frac{\underline{Y}(h) - \underline{Y}(h-1) }{\underline{Y}^*}
\end{equation}


The linear model specified yields marginal costs that are partially independent of the underlying size of the household, and, therefore, may not be appropriate. *Are they partially independent? Not really, because of the exponential functions... The SPLs are partially independent, though.* Specifically, it is possible the that the marginal cost of a first child is larger/smaller in a household with two adults than in a household with one adult. Therefore, we also estimate the nonparametric model in \eqref{eq:nprelation}. To capture the intersection, we apply numeric methods, because the inverse of an unspecified function cannot be determined. 

*Option 1:* First, we fix $D$ and $Z$ to create a data subsample. We use the fixed values of $D$ and $Z$, as well as the observed $\ln Y$ values to predict $\hat{f}$ for all households in the subset. We then choose the $\ln Y$ that is closest to the fitted value, as the subjective poverty line for that household type. *Worry:* this value may not be all that "close". 

*Option 2:* First, we fix $D$ and $Z$. Second, we simulate $\ln Y$ across a wide range. We use the simulated data to predict $\hat{f}$ for all households in the subset. We then choose the simulated $\ln Y$ that is closest to the fitted value, as the subjective poverty line for that household type. *Worry:* this value may not match what households say they spend?

\begin{equation}
\label{eq:nprelation2}
\ln \underline{Y} = \hat{f}(\ln Y,\tilde{D},\tilde{Z})
\end{equation}

-->

## Empirical modelling


```{r lcs-sub}

#, dependson="lcs-np-data"

# Maybe, we want to look at those whose reported values 
# are close to actual? I am not convinced I want to keep it
# How about those whose reported is above their actual?

df.data <- main.df %>%
  dplyr::mutate(min.yq = lny - lnminq) # difference between actual and reported minimum

below.df <- df.data %>%
  filter(min.yq <= 0 )          # reported income always less than reported minimum

above.df <- df.data %>%
  filter(min.yq >= 0 )          # reported income always above reported minimum

# kids limited to max 4 and adults to max 6
dfref <- cbind(k1 = 0, k2 = 0, k3 = 0, k4 = 0, 
               a2 = 0, a3 = 0, a4 = 0, a5 = 0, a6 = 0)

akmat <- base.data %>%
  dplyr::select(ao,ko,
                a1, a2, a3, a4, a5, a6, 
                k0, k1, k2, k3, k4) %>%
  unique() %>%
  arrange(ko) %>%
  group_by(ko) %>%
  arrange(ao) %>%
  ungroup()

dfalt <- akmat %>%
  dplyr::select(k1,k2,k3,k4,
                a2,a3,a4,a5,a6) 

dfdiff <- data.matrix(sweep(dfalt,2,dfref)) 
```



# Results

## Descriptives

## Linear parametric subjective poverty lines

Estimation results from linear model suggest that there is no kid "effect"...However, there are very big education effects. So, I am going to try to match the expenditure with the minq and see if this looks any different?


```{r lineary-spl, dependson="lcs-sub"}

base.data <- df.data
model <- lm(lnminq ~ lny + k1 + k2 + k3 + k4 + 
              a2 + a3 + a4 + a5 + a6 +  age + age.sq + hhh.male + 
              ethnic + province + settle + marital + education,
            data=base.data)

b <- coef(model)[1:11] # does not count non-income and non-adult/child vars.
b1 <- b[3:11]
denom <- 1-b[2]

spl.base <-  exp( (b[1] + (dfdiff %*% b1)) * (1/denom) )

### Bootstrapping - Not the cleanest, but works
boot <- NULL
for (i in 1:399){
  ss <- sample(dim(base.data)[1],replace=T)
  dd <- base.data[c(ss),]
  lnmq.model <- lm(lnminq ~ lny + k1 + k2 + k3 + k4 + 
                     a2 + a3 + a4 + a5 + a6 +  age + age.sq + hhh.male +
                     ethnic + province + settle + marital + education,
                   data=dd)
  cc <- coef(lnmq.model)[1:11]
  cc1 <- cc[3:11]
  denomboot <- 1-cc[2]
  splboot <-  exp( (cc[1] + (dfdiff %*% cc1)) * (1/denom) )
  boot <- cbind(boot,splboot)
}

## Get Eq Scale Standard Deviations
spl.sd <- apply(boot,1,sd)

spl.linminq.yall <- akmat %>%
  dplyr::select(ao,ko) %>%
  mutate(adults = as.integer(ao), kids = as.integer(ko)-1) %>%
  add_column(spl = as.integer(spl.base), 
             spl.sd = as.integer(spl.sd)) %>%
  dplyr::select(-c(ao,ko))

```


```{r linearx-spl, dependson="lcs-sub"}

base.data <- df.data
model <- lm(lnminq ~ lnx + k1 + k2 + k3 + k4 + 
              a2 + a3 + a4 + a5 + a6 +  age + age.sq + hhh.male + 
              ethnic + province + settle + marital + education,
            data=base.data)

b <- coef(model)[1:11] # does not count non-income and non-adult/child vars.
b1 <- b[3:11]
denom <- 1-b[2]

spl.base <-  exp( (b[1] + (dfdiff %*% b1)) * (1/denom) )

### Bootstrapping - Not the cleanest, but works
boot <- NULL
for (i in 1:399){
  ss <- sample(dim(base.data)[1],replace=T)
  dd <- base.data[c(ss),]
  lnmq.model <- lm(lnminq ~ lnx + k1 + k2 + k3 + k4 + 
                     a2 + a3 + a4 + a5 + a6 +  age + age.sq + hhh.male +
                     ethnic + province + settle + marital + education,
                   data=dd)
  cc <- coef(lnmq.model)[1:11]
  cc1 <- cc[3:11]
  denomboot <- 1-cc[2]
  splboot <-  exp( (cc[1] + (dfdiff %*% cc1)) * (1/denom) )
  boot <- cbind(boot,splboot)
}

## Get Eq Scale Standard Deviations
spl.sd <- apply(boot,1,sd)

spl.linminq.xall <- akmat %>%
  dplyr::select(ao,ko) %>%
  mutate(adults = as.integer(ao), kids = as.integer(ko)-1) %>%
  add_column(spl = as.integer(spl.base), 
             spl.sd = as.integer(spl.sd)) %>%
  dplyr::select(-c(ao,ko))

```


```{r lineary-spl-below, dependson="lcs-sub"}

base.data <- below.df
model <- lm(lnminq ~ lny + k1 + k2 + k3 + k4 + 
              a2 + a3 + a4 + a5 + a6 +  age + age.sq + hhh.male + 
              ethnic + province + settle + marital + education,
            data=base.data)

b <- coef(model)[1:11] # does not count non-income and non-adult/child vars.
b1 <- b[3:11]
denom <- 1-b[2]

spl.base <-  exp( (b[1] + (dfdiff %*% b1)) * (1/denom) )

### Bootstrapping - Not the cleanest, but works
boot <- NULL
for (i in 1:399){
  ss <- sample(dim(base.data)[1],replace=T)
  dd <- base.data[c(ss),]
  lnmq.model <- lm(lnminq ~ lny + k1 + k2 + k3 + k4 + 
                     a2 + a3 + a4 + a5 + a6 +  age + age.sq + hhh.male +
                     ethnic + province + settle + marital + education,
                   data=dd)
  cc <- coef(lnmq.model)[1:11]
  cc1 <- cc[3:11]
  denomboot <- 1-cc[2]
  splboot <-  exp( (cc[1] + (dfdiff %*% cc1)) * (1/denom) )
  boot <- cbind(boot,splboot)
}

## Get Eq Scale Standard Deviations
spl.sd <- apply(boot,1,sd)

spl.linminq.ybelow <- akmat %>%
  dplyr::select(ao,ko) %>%
  mutate(adults = as.integer(ao), kids = as.integer(ko)-1) %>%
  add_column(spl = as.integer(spl.base), 
             spl.sd = as.integer(spl.sd)) %>%
  dplyr::select(-c(ao,ko))

```


```{r linearx-spl-below, dependson="lcs-sub"}

base.data <- below.df
model <- lm(lnminq ~ lnx + k1 + k2 + k3 + k4 + 
              a2 + a3 + a4 + a5 + a6 +  age + age.sq + hhh.male + 
              ethnic + province + settle + marital + education,
            data=base.data)

b <- coef(model)[1:11] # does not count non-income and non-adult/child vars.
b1 <- b[3:11]
denom <- 1-b[2]

spl.base <-  exp( (b[1] + (dfdiff %*% b1)) * (1/denom) )

### Bootstrapping - Not the cleanest, but works
boot <- NULL
for (i in 1:399){
  ss <- sample(dim(base.data)[1],replace=T)
  dd <- base.data[c(ss),]
  lnmq.model <- lm(lnminq ~ lnx + k1 + k2 + k3 + k4 + 
                     a2 + a3 + a4 + a5 + a6 +  age + age.sq + hhh.male +
                     ethnic + province + settle + marital + education,
                   data=dd)
  cc <- coef(lnmq.model)[1:11]
  cc1 <- cc[3:11]
  denomboot <- 1-cc[2]
  splboot <-  exp( (cc[1] + (dfdiff %*% cc1)) * (1/denom) )
  boot <- cbind(boot,splboot)
}

## Get Eq Scale Standard Deviations
spl.sd <- apply(boot,1,sd)

spl.linminq.xbelow <- akmat %>%
  dplyr::select(ao,ko) %>%
  mutate(adults = as.integer(ao), kids = as.integer(ko)-1) %>%
  add_column(spl = as.integer(spl.base), 
             spl.sd = as.integer(spl.sd)) %>%
  dplyr::select(-c(ao,ko))

```



```{r lineary-spl-above, dependson="lcs-sub"}

base.data <- above.df
model <- lm(lnminq ~ lny + k1 + k2 + k3 + k4 + 
              a2 + a3 + a4 + a5 + a6 +  age + age.sq + hhh.male + 
              ethnic + province + settle + marital + education,
            data=base.data)

b <- coef(model)[1:11] # does not count non-income and non-adult/child vars.
b1 <- b[3:11]
denom <- 1-b[2]

spl.base <-  exp( (b[1] + (dfdiff %*% b1)) * (1/denom) )

### Bootstrapping - Not the cleanest, but works
boot <- NULL
for (i in 1:399){
  ss <- sample(dim(base.data)[1],replace=T)
  dd <- base.data[c(ss),]
  lnmq.model <- lm(lnminq ~ lny + k1 + k2 + k3 + k4 + 
                     a2 + a3 + a4 + a5 + a6 +  age + age.sq + hhh.male +
                     ethnic + province + settle + marital + education,
                   data=dd)
  cc <- coef(lnmq.model)[1:11]
  cc1 <- cc[3:11]
  denomboot <- 1-cc[2]
  splboot <-  exp( (cc[1] + (dfdiff %*% cc1)) * (1/denom) )
  boot <- cbind(boot,splboot)
}

## Get Eq Scale Standard Deviations
spl.sd <- apply(boot,1,sd)

spl.linminq.yabove <- akmat %>%
  dplyr::select(ao,ko) %>%
  mutate(adults = as.integer(ao), kids = as.integer(ko)-1) %>%
  add_column(spl = as.integer(spl.base), 
             spl.sd = as.integer(spl.sd)) %>%
  dplyr::select(-c(ao,ko))

```


```{r linearx-spl-above, dependson="lcs-sub"}

base.data <- above.df
model <- lm(lnminq ~ lnx + k1 + k2 + k3 + k4 + 
              a2 + a3 + a4 + a5 + a6 +  age + age.sq + hhh.male + 
              ethnic + province + settle + marital + education,
            data=base.data)

b <- coef(model)[1:11] # does not count non-income and non-adult/child vars.
b1 <- b[3:11]
denom <- 1-b[2]

spl.base <-  exp( (b[1] + (dfdiff %*% b1)) * (1/denom) )

### Bootstrapping - Not the cleanest, but works
boot <- NULL
for (i in 1:399){
  ss <- sample(dim(base.data)[1],replace=T)
  dd <- base.data[c(ss),]
  lnmq.model <- lm(lnminq ~ lnx + k1 + k2 + k3 + k4 + 
                     a2 + a3 + a4 + a5 + a6 +  age + age.sq + hhh.male +
                     ethnic + province + settle + marital + education,
                   data=dd)
  cc <- coef(lnmq.model)[1:11]
  cc1 <- cc[3:11]
  denomboot <- 1-cc[2]
  splboot <-  exp( (cc[1] + (dfdiff %*% cc1)) * (1/denom) )
  boot <- cbind(boot,splboot)
}

## Get Eq Scale Standard Deviations
spl.sd <- apply(boot,1,sd)

spl.linminq.xabove <- akmat %>%
  dplyr::select(ao,ko) %>%
  mutate(adults = as.integer(ao), kids = as.integer(ko)-1) %>%
  add_column(spl = as.integer(spl.base), 
             spl.sd = as.integer(spl.sd)) %>%
  dplyr::select(-c(ao,ko))

```


```{r spl-table, dependson="lineary-spl; lineary-spl-below; lineary-spl-above; linearx-spl; linearx-spl-below; linearx-spl-above; some-functions", results="asis", size = "footnotesize"}

spl0 <- estab(spl.linminq.yall) %>% rename(yall=results)
spl1 <- estab(spl.linminq.ybelow) %>% rename(ybelow=results)
spl2 <- estab(spl.linminq.yabove) %>% rename(yabove=results)
spl3 <- estab(spl.linminq.xall) %>% rename(xall=results)
spl4 <- estab(spl.linminq.xbelow) %>% rename(xbelow=results)
spl5 <- estab(spl.linminq.xabove) %>% rename(xabove=results)

spl.tab <- tibble(spl0,spl1[,3],spl2[,3],spl3[,3],spl4[,3],spl5[,3])


kable(spl.tab, format = "latex", align='rrrrrr',
      row.names = F,
      booktabs=TRUE, escape=FALSE, longtable=TRUE,
      linesep="",
      caption="Estimate of subjective poverty lines based on minimum household income, underpinned by linear regression model",
      col.names=c("Adults","Kids","All HH","Below","Above","All HH","Below","Above")) %>%
  add_header_above(c(" "=2, "Household Income"=3, "Household Expenditure" = 3)) %>%
  kable_styling(latex_options = c("striped", "hold_position", position="center")) %>%
  footnote(general = "Estimated poverty lines by household type (adults and kids), differentiated by whether we use all households, or those who report their income to be less than what is required. Bootstrapped standard errors (399 replications) are reported in paranethesis for each household type and regression control. Estimates underpinned by linear model of minimum income income required by the household against a range of controls including reported household (log) income or expenditure, household structure and location dummies.", escape=FALSE, general_title="",threeparttable=TRUE) 
```

# Quadratic parametric subjective poverty lines


```{r quady-spl, dependson="lcs-sub"}

base.data <- df.data
model <- lm(lnminq ~ lny + lny.sq + k1 + k2 + k3 + k4 + 
              a2 + a3 + a4 + a5 + a6 +  age + age.sq + hhh.male + 
              ethnic + province + settle + marital + education,
            data=base.data)

bcoef <- coef(model)[1:12] # does not count non-income and non-adult/child vars.
bcoef1 <- bcoef[4:12]

# This calculates for all household types at once... but no real roots?
c <- (bcoef[1] + (dfdiff %*% bcoef1))
b <- bcoef[2] - 1
a <- bcoef[3]

discriminant <- (b^2) - (4*a*c)

# How to choose?
root1 <- (-b + sqrt(discriminant))*(1/(2*a))
root2 <- (-b - sqrt(discriminant))*(1/(2*a))

spl.base <-  exp( root2 )

### Bootstrapping - Not the cleanest, but works
boot <- NULL
for (i in 1:399){
  ss <- sample(dim(base.data)[1],replace=T)
  dd <- base.data[c(ss),]
  lnmq.model <- lm(lnminq ~ lny + lny.sq + k1 + k2 + k3 + k4 + 
                     a2 + a3 + a4 + a5 + a6 +  age + age.sq + hhh.male +
                     ethnic + province + settle + marital + education,
                   data=dd)
  cc <- coef(lnmq.model)[1:12]
  cc1 <- cc[4:12]
  c <- (cc[1] + (dfdiff %*% cc1))
  b <- cc[2] - 1
  a <- cc[3]
  discriminant <- (b^2) - (4*a*c)
  root2 <- (-b - sqrt(discriminant))*(1/(2*a))
  splboot <-  exp( root2 )
  boot <- cbind(boot,splboot)
}

## Get Eq Scale Standard Deviations
spl.sd <- apply(boot,1,sd)

spl.qminq.yall <- akmat %>%
  dplyr::select(ao,ko) %>%
  mutate(adults = as.integer(ao), kids = as.integer(ko)-1) %>%
  add_column(spl = as.integer(spl.base), 
             spl.sd = as.integer(spl.sd)) %>%
  dplyr::select(-c(ao,ko))

```


```{r quadx-spl, dependson="lcs-sub"}

base.data <- df.data
model <- lm(lnminq ~ lnx + lnx.sq + k1 + k2 + k3 + k4 + 
              a2 + a3 + a4 + a5 + a6 +  age + age.sq + hhh.male + 
              ethnic + province + settle + marital + education,
            data=base.data)

bcoef <- coef(model)[1:12] # does not count non-income and non-adult/child vars.
bcoef1 <- bcoef[4:12]

# This calculates for all household types at once... but no real roots?
c <- (bcoef[1] + (dfdiff %*% bcoef1))
b <- bcoef[2] - 1
a <- bcoef[3]

discriminant <- (b^2) - (4*a*c)

# How to choose?
root1 <- (-b + sqrt(discriminant))*(1/(2*a))
root2 <- (-b - sqrt(discriminant))*(1/(2*a))

spl.base <-  exp( root2 )

### Bootstrapping - Not the cleanest, but works
boot <- NULL
for (i in 1:399){
  ss <- sample(dim(base.data)[1],replace=T)
  dd <- base.data[c(ss),]
  lnmq.model <- lm(lnminq ~ lnx + lnx.sq + k1 + k2 + k3 + k4 + 
                     a2 + a3 + a4 + a5 + a6 +  age + age.sq + hhh.male +
                     ethnic + province + settle + marital + education,
                   data=dd)
  cc <- coef(lnmq.model)[1:12]
  cc1 <- cc[4:12]
  c <- (cc[1] + (dfdiff %*% cc1))
  b <- cc[2] - 1
  a <- cc[3]
  discriminant <- (b^2) - (4*a*c)
  # How to choose?
  root2 <- (-b - sqrt(discriminant))*(1/(2*a))
  splboot <-  exp( root2 )
  boot <- cbind(boot,splboot)
}

## Get Eq Scale Standard Deviations
spl.sd <- apply(boot,1,sd)

spl.qminq.xall <- akmat %>%
  dplyr::select(ao,ko) %>%
  mutate(adults = as.integer(ao), kids = as.integer(ko)-1) %>%
  add_column(spl = as.integer(spl.base), 
             spl.sd = as.integer(spl.sd)) %>%
  dplyr::select(-c(ao,ko))

```


```{r spl-table-quad, dependson="quady-spl; quadx-spl; some-functions", results="asis", size = "footnotesize"}

spl0 <- estab(spl.qminq.yall) %>% rename(yall=results)
#spl1 <- estab(spl.linminq.ybelow) %>% rename(ybelow=results)
#spl2 <- estab(spl.linminq.yabove) %>% rename(yabove=results)
spl3 <- estab(spl.qminq.xall) %>% rename(xall=results)
#spl4 <- estab(spl.linminq.xbelow) %>% rename(xbelow=results)
#spl5 <- estab(spl.linminq.xabove) %>% rename(xabove=results)

spl.tab <- tibble(spl0,spl3[,3])


kable(spl.tab, format = "latex", align='rr',
      row.names = F,
      booktabs=TRUE, escape=FALSE, longtable=TRUE,
      linesep="",
      caption="Estimate of subjective poverty lines based on minimum household income, underpinned by linear regression model",
      col.names=c("Adults","Kids","All HH","All HH")) %>%
  add_header_above(c(" "=2, "Household Income"=1, "Household Expenditure" = 1)) %>%
  kable_styling(latex_options = c("striped", "hold_position", position="center")) %>%
  footnote(general = "Estimated poverty lines by household type (adults and kids), differentiated by whether we use all households, or those who report their income to be less than what is required. Bootstrapped standard errors (399 replications) are reported in paranethesis for each household type and regression control. Estimates underpinned by linear model of minimum income income required by the household against a range of controls including reported household (log) income or expenditure, household structure and location dummies.", escape=FALSE, general_title="",threeparttable=TRUE) 
```

# Smooth kids and adults


```{r lineary-spl-smooth, dependson="lcs-sub"}

base.data <- df.data %>%
  mutate(ao = as.numeric(ao),
         ko = as.numeric(ko))

model <- lm(lnminq ~ lny + ao + ko +  age + age.sq + hhh.male + 
              ethnic + province + settle + marital + education,
            data=base.data)

b <- coef(model)[1:4] # does not count non-income and non-adult/child vars.
b1 <- b[3:4]          # just the kids and adult bit
denom <- 1-b[2]

dfdiff <- akmat %>% dplyr::select(ao,ko) %>% 
  mutate(ao = as.numeric(ao),
         ko = as.numeric(ko)) %>%
  as.matrix()

spl.base <-  exp( (b[1] + (dfdiff %*% b1)) * (1/denom) )

### Bootstrapping - Not the cleanest, but works
boot <- NULL
for (i in 1:399){
  ss <- sample(dim(base.data)[1],replace=T)
  dd <- base.data[c(ss),]
  lnmq.model <- lm(lnminq ~ lny + ao + ko +  age + age.sq + hhh.male +
                     ethnic + province + settle + marital + education,
                   data=dd)
  cc <- coef(lnmq.model)[1:4]
  cc1 <- cc[3:4]
  denomboot <- 1-cc[2]
  splboot <-  exp( (cc[1] + (dfdiff %*% cc1)) * (1/denom) )
  boot <- cbind(boot,splboot)
}

## Get Eq Scale Standard Deviations
spl.sd <- apply(boot,1,sd)

spl.smoothminq.yall <- akmat %>%
  dplyr::select(ao,ko) %>%
  mutate(adults = as.integer(ao), kids = as.integer(ko)-1) %>%
  add_column(spl = as.integer(spl.base), 
             spl.sd = as.integer(spl.sd)) %>%
  dplyr::select(-c(ao,ko))

```


```{r linearx-spl-smooth, dependson="lcs-sub"}

base.data <- df.data %>%
  mutate(ao = as.numeric(ao),
         ko = as.numeric(ko))

model <- lm(lnminq ~ lnx + ao + ko +  age + age.sq + hhh.male + 
              ethnic + province + settle + marital + education,
            data=base.data)

b <- coef(model)[1:4] # does not count non-income and non-adult/child vars.
b1 <- b[3:4]          # just the kids and adult bit
denom <- 1-b[2]

dfdiff <- akmat %>% dplyr::select(ao,ko) %>% 
  mutate(ao = as.numeric(ao),
         ko = as.numeric(ko)) %>%
  as.matrix()

spl.base <-  exp( (b[1] + (dfdiff %*% b1)) * (1/denom) )

### Bootstrapping - Not the cleanest, but works
boot <- NULL
for (i in 1:399){
  ss <- sample(dim(base.data)[1],replace=T)
  dd <- base.data[c(ss),]
  lnmq.model <- lm(lnminq ~ lnx + ao + ko +  age + age.sq + hhh.male +
                     ethnic + province + settle + marital + education,
                   data=dd)
  cc <- coef(lnmq.model)[1:4]
  cc1 <- cc[3:4]
  denomboot <- 1-cc[2]
  splboot <-  exp( (cc[1] + (dfdiff %*% cc1)) * (1/denom) )
  boot <- cbind(boot,splboot)
}

## Get Eq Scale Standard Deviations
spl.sd <- apply(boot,1,sd)

spl.smoothminq.xall <- akmat %>%
  dplyr::select(ao,ko) %>%
  mutate(adults = as.integer(ao), kids = as.integer(ko)-1) %>%
  add_column(spl = as.integer(spl.base), 
             spl.sd = as.integer(spl.sd)) %>%
  dplyr::select(-c(ao,ko))

```


```{r quady-spl-smooth, dependson="lcs-sub"}

base.data <- df.data %>%
  mutate(ao = as.numeric(ao),
         ko = as.numeric(ko))

model <- lm(lnminq ~ lny + lny.sq + ao + ko +  age + age.sq + hhh.male + 
              ethnic + province + settle + marital + education,
            data=base.data)

b <- coef(model)[1:5] # does not count non-income and non-adult/child vars.
b1 <- b[4:5]          # just the kids and adult bit


dfdiff <- akmat %>% dplyr::select(ao,ko) %>% 
  mutate(ao = as.numeric(ao),
         ko = as.numeric(ko)) %>%
  as.matrix()

# This calculates for all household types at once... but no real roots?
c <- (b[1] + (dfdiff %*% b1))
bb <- b[2] - 1
a <- b[3]

discriminant <- (bb^2) - (4*a*c)

# How to choose?
root1 <- (-bb + sqrt(discriminant))*(1/(2*a))
root2 <- (-bb - sqrt(discriminant))*(1/(2*a))

# do not understand why not working?
spl.base <-  exp( root2 )


### Bootstrapping - Not the cleanest, but works
boot <- NULL
for (i in 1:399){
  ss <- sample(dim(base.data)[1],replace=T)
  dd <- base.data[c(ss),]
  lnmq.model <- lm(lnminq ~ lny + lny.sq + ao + ko +  age + age.sq + hhh.male +
                     ethnic + province + settle + marital + education,
                   data=dd)
  cc <- coef(lnmq.model)[1:5]
  cc1 <- cc[4:5]
  c <- (cc[1] + (dfdiff %*% cc1))
  bb <- cc[2] - 1
  a <- cc[3]
  #discriminant <- (bb^2) - (4*a*c)
  root2 <- (-bb - sqrt(discriminant))*(1/(2*a))
  splboot <-  exp( root2 )
  boot <- cbind(boot,splboot)
}

## Get Eq Scale Standard Deviations
spl.sd <- apply(boot,1,sd)

spl.smoothqminq.yall <- akmat %>%
  dplyr::select(ao,ko) %>%
  mutate(adults = as.integer(ao), kids = as.integer(ko)-1) %>%
  add_column(spl = as.integer(spl.base), 
             spl.sd = as.integer(spl.sd)) %>%
  dplyr::select(-c(ao,ko))

```


```{r quadx-spl-smooth, dependson="lcs-sub"}

base.data <- df.data %>%
  mutate(ao = as.numeric(ao),
         ko = as.numeric(ko))

model <- lm(lnminq ~ lnx + lnx.sq + ao + ko +  age + age.sq + hhh.male + 
              ethnic + province + settle + marital + education,
            data=base.data)

b <- coef(model)[1:5] # does not count non-income and non-adult/child vars.
b1 <- b[4:5]          # just the kids and adult bit


dfdiff <- akmat %>% dplyr::select(ao,ko) %>% 
  mutate(ao = as.numeric(ao),
         ko = as.numeric(ko)) %>%
  as.matrix()

# This calculates for all household types at once... but no real roots?
c <- (b[1] + (dfdiff %*% b1))
bb <- b[2] - 1
a <- b[3]

discriminant <- (bb^2) - (4*a*c)

# How to choose?
root1 <- (-bb + sqrt(discriminant))*(1/(2*a))
root2 <- (-bb - sqrt(discriminant))*(1/(2*a))

spl.base <-  exp( root2 )

### Bootstrapping - Not the cleanest, but works
boot <- NULL
for (i in 1:399){
  ss <- sample(dim(base.data)[1],replace=T)
  dd <- base.data[c(ss),]
  lnmq.model <- lm(lnminq ~ lnx + lnx.sq + ao + ko +  age + age.sq + hhh.male +
                     ethnic + province + settle + marital + education,
                   data=dd)
  cc <- coef(lnmq.model)[1:5]
  cc1 <- cc[4:5]
  c <- (cc[1] + (dfdiff %*% cc1))
  bb <- cc[2] - 1
  a <- cc[3]
  #discriminant <- (bb^2) - (4*a*c)
  root2 <- (-bb - sqrt(discriminant))*(1/(2*a))
  splboot <-  exp( root2 )
  boot <- cbind(boot,splboot)
}

## Get Eq Scale Standard Deviations
spl.sd <- apply(boot,1,sd)

spl.smoothqminq.xall <- akmat %>%
  dplyr::select(ao,ko) %>%
  mutate(adults = as.integer(ao), kids = as.integer(ko)-1) %>%
  add_column(spl = as.integer(spl.base), 
             spl.sd = as.integer(spl.sd)) %>%
  dplyr::select(-c(ao,ko))

```


```{r spl-table-smooth, dependson="lineary-spl-smooth; linearx-spl-smooth; quadx-spl-smooth; quady-spl-smooth; some-functions", results="asis", size = "footnotesize"}

spl0 <- estab(spl.smoothminq.yall) %>% rename(yall=results)
spl1 <- estab(spl.smoothqminq.yall) %>% rename(yquad=results)
#spl2 <- estab(spl.linminq.yabove) %>% rename(yabove=results)
spl3 <- estab(spl.smoothminq.xall) %>% rename(xall=results)
spl4 <- estab(spl.smoothqminq.xall) %>% rename(xquad=results)
#spl5 <- estab(spl.linminq.xabove) %>% rename(xabove=results)

spl.tab <- tibble(spl0,spl1[,3],spl3[,3],spl4[,3])


kable(spl.tab, format = "latex", align='rrrr',
      row.names = F,
      booktabs=TRUE, escape=FALSE, longtable=TRUE,
      linesep="",
      caption="Estimate of subjective poverty lines based on minimum household income, underpinned by linear regression model",
      col.names=c("Adults","Kids","Linear","Quadratic","Linear","Quadratic")) %>%
  add_header_above(c(" "=2, "Household Income"=2, "Household Expenditure" = 2)) %>%
  kable_styling(latex_options = c("striped", "hold_position", position="center")) %>%
  footnote(general = "Estimated poverty lines by household type (adults and kids), differentiated by whether we use all households, or those who report their income to be less than what is required. Bootstrapped standard errors (399 replications) are reported in paranethesis for each household type and regression control. Estimates underpinned by linear model of minimum income income required by the household against a range of controls including reported household (log) income or expenditure, household structure and location dummies.", escape=FALSE, general_title="",threeparttable=TRUE) 
```


\newpage
\singlespacing
# References {-}